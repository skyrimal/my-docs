# 一。spring的整体架构

## 1. Core Container模块

> 核心容器包括Core、Beans、Context和Expression Language模块

### Core

Core模块是Spring框架基本核心工具类包**所有的组件都会使用到==Core==模块**

### Beans

包含访问配置文件、创建和管理Bean以及进行Inversion of Control/Dependency Injection （IOC/DI）==>控制反转，依赖注入

### Context

**Context容器模块**是对**Beans的管理**，并提供了大量扩展

扩展：对**国际化**（如资源绑定）、**事件传播**、**资源加载**和对Context的**透明创建的支持**

支持J2EE一些特性，例：

和基础的远程处理

**ApplicationContext**是**Context**的入口

### Expression Lauguage

提供强大的表达式语言，用于**查询和操纵对象**

支持**设置/获取属性的值**;**属性的分配**;**方法的调用**;**访问数组上下文**（accessiong the context of arrays）、**容器**和**索引器**、**逻辑**和**算术运算符**、**命名变量**以及从Spring和IoC容器中根据名称检索对象

支持**list投影**、**选择**和一般的**list聚会**

## 2. Data Access/Integration

包含JDBC、ORM、OXM、JMS和Transaction模块

### JDBC

> Spring对数据库访问的工具模块

提供的是**JDBC抽象层**，对JDBC规范的同时可以消除冗长的JDBC编码和解析数据库厂商特有的错误代码

包含**Spring**对**JDBC**数据访问进行封装的所有类

### ORM

包含常用*对象-关系映射工具*的**API**调用集成，如JPA、JDO、Hibernate、iBatis等，提供了交互层。

可使用所有Spring提供的特性进行O/R映射，进行如简单的声明式事务管理操作

> Spring插入了多个ORM框架，提供多个对象关系工具的交互API，
>
> 我暂时想象成Spring交互门面，例如日志门面SLF4j
>
> ![img](D:%5Cgit%5Cspringsource%5Clearn-notes%5C%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9Aspring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%8E%AF%E5%A2%83%5C2021-01.assets%5C2909474-b5127a18b3eda3ec.png)

### OXM

提供了**Object/XML映射**实现的抽象层，**Object/XMl映射**包括JDO、Hibernate、iBatisSQL Map，都遵从Spring通用事务和DAO已成层次结构

功能：实践类与xml之间的相互转换。

编组：marshalling 将javabean转化为xml

解组：unmarshalling 将xml转化为JavaBean

> 事务：本质上其实是同一个概念,spring的事务是对数据库的事务的封装,最后本质的实现还是在数据库,假如数据库不支持事务的话,spring的事务是没有作用的.数据库的事务说简单就只有开启,回滚和关闭,spring对数据库事务的包装,原理就是拿一个数据连接,根据spring的事务配置,操作这个数据连接对数据库进行事务开启,回滚或关闭操作.但是spring除了实现这些,还配合spring的传播行为对事务进行了更广泛的管理.其实这里还有个重要的点,那就是事务中涉及的隔离级别,以及spring如何对数据库的隔离级别进行封装.事务与隔离级别放在一起理解会更好些.以上回答希望能帮助到你. 
>
> 事务必须服从ISO/IEC所制定的ACID原则。ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写
>
> ### **ACID原则**
>
> **1、原子性**
>
> 即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换
>
> **2、一致性**
>
> 事务的执行使得数据库从一种正确状态转换成另外一种正确状态
>
> **3、隔离性**
>
> 在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务
>
> **4、持久性**
>
> 事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存
>
> ### **并发下事务会产生的问题**
>
> **1、脏读**
>
> 所谓脏读，就是指**事务A读到了事务B还没有提交的数据**，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务-->取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。
>
> **2、不可重复读**
>
> 所谓不可重复读，就是指**在一个事务里面读取了两次某个数据，读出来的数据不一致**。还是以银行取钱为例，事务A开启事务-->查出银行卡余额为1000元，此时切换到事务B事务B开启事务-->事务B取走100元-->提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。
>
> **3、幻读**
>
> 所谓幻读，就是指**在一个事务里面的操作中发现了未被操作的数据**。比如学生信息，事务A开启事务-->修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务-->事务B删除了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。
>
> ### **事务隔离级别**
>
> 事务隔离级别，就是为了解决上面几种问题而诞生的。为什么要有事务隔离级别，因为**事务隔离级别越高，在并发下会产生的问题就越少，但同时付出的性能消耗也将越大**，因此很多时候必须在并发性和性能之间做一个权衡。所以设立了几种事务隔离级别，以便让不同的项目可以根据自己项目的并发情况选择合适的事务隔离级别，对于在事务隔离级别之外会产生的并发问题，在代码中做补偿。
>
> 事务隔离级别有4种，但是像Spring会提供给用户5种，来看一下：
>
> **1、DEFAULT**
>
> 默认隔离级别，每种数据库支持的事务隔离级别不一样，如果Spring配置事务时将isolation设置为这个值的话，那么将使用底层数据库的默认事务隔离级别。顺便说一句，如果使用的MySQL，可以使用"**select @@tx_isolation**"来查看默认的事务隔离级别
>
> **2、READ_UNCOMMITTED**
>
> 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用
>
> **3、READ_COMMITED**
>
> 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读
>
> **4、REPEATABLE_READ**
>
> 重复读取，即在数据读出来之后加锁，类似"select * from XXX  for  update"，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决
>
> **5、SERLALIZABLE**
>
> 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了
>
> 网上专门有图用表格的形式列出了事务隔离级别解决的并发问题：
>
> ![img](D:%5Cgit%5Cspringsource%5Clearn-notes%5C%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9Aspring%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%8E%AF%E5%A2%83%5C2021-01.assets%5C801753-20151229231850151-1072203985.png)
>
> 再必须强调一遍，不是事务隔离级别设置得越高越好，事务隔离级别设置得越高，意味着势必要花手段去加锁用以保证事务的正确性，那么效率就要降低，因此实际开发中往往要在效率和并发正确性之间做一个取舍，一般情况下会设置为READ_COMMITED，此时避免了脏读，并发性也还不错，之后再通过一些别的手段去解决不可重复读和幻读的问题就好了。

### JMS

制作和消费消息的特性

### Transation

支持**编程**和**声明性**的**事务管理**

事务类必须实现指定接口，对所有POJO都适用

## 3.Web

web模块建立在**应用程序上下文模块==Context**之上，为基于Web的应用程序提供了上下文

支持Jakarta Struts的集成。

简化了处理大部分请求、将请求参数绑定到域对象的工作。

包含Web、Web-Servlet、Web-Struts和Web-Porlet模块 

### Web

提供基础面向Web的集成特性

> 多文件上传、使用servelet listioners初始化IoC容器、慢性Web的应用上下文
>
> Spring远程支持Web部分

### Web-Servlet

包含Spring的**model-view-controller(mvc)的实现**

> mvc：使模型范围内的代码和web froms直接能够清楚地分离开，并和Spring框架的其他特性集成在一起

### Web-Struts

提供了对**Struts**的支持，使类能在Spring应用中与Struts Web层集成在一起**==Spring 3.0已弃用==**

### Web-Porlet

用于**Porlet**环境和**Web-Servlet**模块的**MVC**的实现

## 4.AOP

提供一个标准的面向切面编程的实现，可以定义方法拦截器和切点，将**逻辑代码分开**，降低代码之间的**耦合性**

利用source-level的元数据功能，将各种行为信息合并到代码中

Spring AOP模块为**基于Spring的应用程序**对象提供了**事务管理**服务

> AOP中的事务管理是Spring主要的事务管理功能

### Aspects

提供AspectJ集成

### Instrumentation

提供了class instrumentation和classloader实现，可以使在特定的应用服务器上使用

## 5.Test

支持JUnit和TestNG对Spring组件进行测试