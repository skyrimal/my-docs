# 5.6 循环依赖

## 5.6.1 什么是循环依赖

![循环依赖](5.6%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.assets/b7fd5266d01609240b215e97c00254fce7cd34c5.jpeg)

由图即可知

## 5.6.2 Spring如何解决循环依赖

Spring将循环依赖的处理分成了三种情况

1. 构造器注入循环依赖

   1. 这种依赖是无法解决的，只能抛出==BeanCurrentlyInCreationException==异常
   2. 当bean要注入当前bean时，发现该bean已在“==当前创建bean池==”中，就会抛出异常

2. Setter循环依赖

   1. 通过setter注入造成依赖时通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤——==这里就指的setter==——的bean来完成的，只能解决单例bean的循环依赖

   2. 通过暴露单例工厂的方法，使其他bean能引用到该bean

   3. 想要获取一个beanA步骤 下面是递归调用———垃圾书，又没有讲清楚目标和返回结果

      > 通过代理ObjectFactory接口实现来返回不同的object

      1. 根据无参构造器创建beanA，暴露一个beanA的“==ObjectFactory==”，将beanA放入“==当前创建bean池==”，并进行setter注入beanB
      2. 根据无参构造器创建beanB，暴露一个beanB的“==ObjectFactory==”，将beanB放入“==当前创建bean池==”，并进行setter注入beanC
      3. 根据无参构造器创建beanC，暴露一个beanC的“==ObjectFactory==”，将beanC放入“==当前创建bean池==”，并进行setter注入beanA，因为发现beanA已在“==当前创建bean池==”中，发现“==当前创建bean池==”中有beanA，将beanA注入beanC并返回继续处理beanB
      4. 继续第二步，发现“==当前创建bean池==”有beanC，将其注入beanB后返回并继续处理beanA
      5. 继续第一步，发现“==当前创建bean池==”有beanB，将其注入beanA后返回，到此，跳出循环依赖处理，且获取了一个循环依赖的实例

3. 对于prototype作用域来说，因为其不缓存，所以无法通过暴露ObjectFactory来获取bean，即无法从缓存中判断当前bean是否已经创建

