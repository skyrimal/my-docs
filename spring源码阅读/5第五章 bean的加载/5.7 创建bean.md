# 5.7 创建bean

创建bean的流程

1. 如果是单例bean，则优先清除缓存

2. 实例化bean，将BeanDefinition转换为BeanWrapper

   1. 如果存在工厂方法则使用工厂方法初始化
   2. 根据参数锁定构造函数并进行初始化
   3. 如果不是工厂方法也不存在带参数的构造器，则使用默认的构造函数进行bean的实例化
   4. 处理完成后更新beanDefinition对应的resolvedTargetType–解析目标属性

3. MergedBeanDefinitionPostProcessor对合并后的benaDefinition进行处理，@Autowired通过此方法实现注入类型的预解析

4. 依赖处理前

   1. 如果允许循环依赖，在创建bean时就会进行循环依赖的处理

   2.  提前曝光ObjectFactory  主要目的是暴露出当前正在处理的bean的地址

      ```java
      addSingletonFactory(beanName,
            //对bean再一次依赖引用，注意引用SmartInstantiationAware【智能实例化感知】 BeanPort
            //Peocessor
            //AOP就是在这里将advice动态织入bean中的 advice--增强 切面在特定接入点的执行动作，包括 “around,” “before” and "after"等多种类型
            () -> getEarlyBeanReference(beanName, mbd, bean));
      ```

5. 初始化返回实例

   1. 初始化要返回的 exposedObject，将属性填入，这里会触发递归

6. 循环依赖检查 只对单例起效

   1. 判断当前beanName是否已经在“==正在解析的bean池==”中，如果在，说明到了循环注入的尾节点，进入第二步

   2. 判断有没有进行加强处理（MergedBeanDefinitionPostProcessor处理，没有进行处理返回原bean）

      ```java
      			Object earlySingletonReference = getSingleton(beanName, false);
      			if (earlySingletonReference != null) {//只有检查到循环依赖是才不为空
      				if (exposedObject == bean) {//如果暴露的bean跟加工后的bean相同，说明没有进行增强处理
      					exposedObject = earlySingletonReference;//如果没有操作则进行倒退处理
      				}
      ```

   3. 如果有进行加强处理并且允许未经包装的注射则判断“==正在解析的bean池==”中依赖有没有未实例化依赖，有则抛错，没有则通过

7. 注册bean到对应的scope中便于销毁时调用

8. 返回暴露的exposedObject

### 1 autowireConstructor

 选择构造函数初始化实例并存进BeanWrapper中

#### 1. 确定构造参数

通过传入的explicitArgs参数判断构造函数参数——传入的就是构造函数参数

缓存中获取构造函数参数——当完成构造后，回将构造函数参数存进该实例的BeanDefinition中

	>这里要注意 ，缓存中获取的参数类型不一定满足构造器参数类型，所以要解析参数类型

**新版补充会提前尝试获取从class中获取所有构造器，判定如果只能使用默认无参构造器时直接构造返回

从配置中获取——配置文件都解析到BeanDefinition中，所以，可以从定义中调用getConstructorArgumentValues尝试获取配置的构造函数信息

#### 2. 构造函数的确定

如果有选中的构造函数直接使用

如果解析后只有一个构造函数且未解析出构造参数，则使用无参构造去构造并返回

接下来按参数数量解析出构造函数最少参数数量minNrOfArgs用来循环判断

给构造函数排序，public构造函数按优先参数数量降序，非public构造函数按参数数量降序

#### 3. 根据构造函数转换构造参数类型

将参数与构造器函数参数进行绑定

#### 4. 构造函数不确定性验证

遍历所有构造函数，当找到构造函数直接跳出，当构造函数参数数量少于minNrOfArgs时跳过

检查不确定性的构造函数是否存在，不确定性指参数是否为父子关系，返回权重typeDiffWeight

正常的typeDiffWeight小于Integer.MAX_VALUE，当其正常则选中该构造器

不正常则将构造函数记录，如果最后记录不为空，宽松策略下，可使用模糊的构造函数，非宽松策略下，如果选中了模糊构造器直接报错

#### 5. 实例化并保存到BeanWrapper





