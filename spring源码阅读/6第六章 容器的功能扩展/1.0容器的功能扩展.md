# 6. 容器的功能扩展

## 6.0 容器上下文的架构

![image-20211103214345146](1.0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95.assets/image-20211103214345146-16359470280131.png)



可见，一个基本的应用上下文ApplicationContext是由ResourceLoader、部分BeanFactory组成的。

ApplicationContext扩展有EnvironmentCapable、ApplicationEventPublisher、MessageSource组成的

ConfigurableApplicationContext是在ApplicationContext和Lifecycle、AutoCloseable组成

### ResourceLoader:

定义用于加载资源和类加载器的方法。

### BeanFactory:

定义获取bean和bean的属性

### DefaultResourceLoader:

实现了ResourceLeader的方法，是AbstractApplicationContext的基类

### ResourcePatternResolver:

继承自ResourceLoader，增加了对有*的资源路径加载的定义。

### HierachicalBeanFactory:

继承自BeanFactory，增加了对parentFactory层级的支持定义。

### ListableBeanFactory

继承自BeanFactory，增加了通过各种条件获取bean的配置清单的定义。

### EnvironmentCapable

定义了获取环境信息的接口

### ApplicationEventPublisher

定义了事件发布的方法，可以选择传入ApplicationEvent或者Object

### MessageSource

支持参数化、国际化的解析消息的策略接口

### AutoCloseable

try-with-resource使用的接口，定义了关闭资源的方法，

实现了该接口的类在

try(AutoCloseable a = new BufferedReader(new FileReader(fileName))){}catch(Exception e){}

语法中，执行后资源会自动关闭，关闭资源的异常会一并在catch中抛出

### ApplicationContext

继承了ResourcePatternResolver、HierarchicalBeanFactory、EnvironmentCapable、ApplicationEventPublisher、MessageSource接口。

是容器通过应用程序上下文环境创建、获取、管理bean。为应用程序提供配置的中央接口。

### Lifecyle

定义了该bean开关功能，可以给bean添加开关状态，使用isRunning()来判断该bean是否关闭。

### Closeable

继承自AutoCloseable，修改了AutoCloseable的close抛出的异常，从Exception改为IOException。

### ConfigurableApplicationContext

继承自ApplicationContext，添加了对Lifecyle、Closeable的整合，是Application系列接口的功能整合。

类似于ConfigurableListableBeanFactory对BeanFactory功能的整合。

### AbstractApplicationContext

继承自DefaultResourceLoader，并初步实现了ConfigurableApplicationContext接口的初始化容器的全部功能。

作用主要是开始搭建起应用容器的基本各种属性。

### Aware

标记用接口，将实现类/继承接口标记为会被感知的类型。

### AbstractRefreshableApplicationContext

继承了AbstractApplicationContext，添加了一点涉及容器运行方式的属性的配置方法，实现了对bean工厂的初始化，并加载了BeanDefinition到工厂中。

### InitializingBean

InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。

### BeanNameAware

实现BeanNameAware接口需要实现setBeanName()方法，在创建后就可以获取到当前的beanName。

### AbstractRefreshableConfigApplicationContext

继承自AbstractRefreshableApplicationContext，实现了BeanNameAware和InitializingBean添加了一些配置信息插入的方法



![image-20210815152816137](1.0%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95.assets/image-20210815152816137.png)

真正最重要的入口类

```
AbstractRefreshableConfigApplicationContext.java
包含资源所有的路径
保护应用最重要的方法--refresh()
```



传入多个给定路径地址进行解析

```java
	//路径，支持传入数组
	public ClassPathXmlApplicationContext(
			String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
			throws BeansException {
		//如果有，添加父应用
		super(parent);
		//给当前应用添加资源地址
		setConfigLocations(configLocations);
		if (refresh) {
			//是否刷新应用--即启动所有的配置
			//解析功能的实现
			//--context--最难的方法，没有之一
			refresh();
		}
	}
```

解析完资源后 refresh() 进行配置数据复位

## 6.1 设置配置路径

如果有特殊符${var}，resolvePath会搜索匹配的系统变量并替换

```java
	public void setConfigLocations(@Nullable String... locations) {//给定路径地址
		if (locations != null) {
			Assert.noNullElements(locations, "Config locations must not be null");
			this.configLocations = new String[locations.length];
			for (int i = 0; i < locations.length; i++) {
				//解析给定路径
				this.configLocations[i] = resolvePath(locations[i]).trim();
			}
		}
		else {
			this.configLocations = null;
		}
	}
```

## 6.2 扩展功能

* **prepareRefresh();**  

  准备此上下文以进行刷新，本方法可以在项目启动前对必需的变量进行存在性验证

*  **ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();**

   告诉子类刷新内部bean工厂。会复用BeanFactory的配置文件读取解析及其他功能，执行后Context就包含了BeanFactory的功能功能

*  **prepareBeanFactory(beanFactory);**

   准备bean工厂，以便在此上下文中使用。--对beanFactory进行功能填充，比如@Autowired、@Qualifier等注解就是在这一步骤中添加的支持

* **postProcessBeanFactory(beanFactory);**

   允许在上下文子类中对bean工厂进行后处理。--子类覆盖方法做额外的处理

   空方法，用来由用户进行自定义扩展

* **invokeBeanFactoryPostProcessors(beanFactory);**

   调用在上下文中注册为bean的工厂处理器。--激活各种BeanFactory处理器

* **registerBeanPostProcessors(beanFactory);**

   注册拦截bean创建的bean处理器。--这里只注册，调用是在getBean的时候

* **initMessageSource();**

   为此上下文初始化Message源，即不同语言的消息体，国际化处理

* **initApplicationEventMulticaster();**

   为此上下文初始化事件多播。--初始化应用事件广播器，并放入“applicationEventMulticaster”bean中

* **onRefresh();**

   初始化特定上下文子类中的其他特殊bean。--留给子类来实例化其他的bean

* **registerListeners();**

   检查侦听器Listener bean并注册它们到事件广播器中。

* **finishBeanFactoryInitialization(beanFactory);**

   实例化所有剩余的（非惰性初始化）单例。

* **finishRefresh();**

   通知生命周期处理器lifecycleProcessor刷新过程，发出ContextRefreshEvent事件通知

## 6.3 **prepareRefresh();**

都是准备活动

1. 激活上下文的状态

   ```java
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);
   ```

2. 打印刷新日志

   ```java
   if (logger.isDebugEnabled()) {
      if (logger.isTraceEnabled()) {
         logger.trace("Refreshing " + this);
      }
      else {
         logger.debug("Refreshing " + getDisplayName());
      }
   }
   ```

3. 调用空方法initPropertySources()

   ```java
   // Initialize any placeholder property sources in the context environment.
   //初始化上下文环境中的任何占位符属性源。
   //留给子类覆盖--用户可以自定义重写该方法，并对个性化属性进行处理及设置
   initPropertySources();
   ```

4. 验证系统环境是否都有项目需要属性

   ```java
   // Validate that all properties marked as required are resolvable:
   // see ConfigurablePropertyResolver#setRequiredProperties
   //验证标记为必需的所有属性是否可解析--需要的属性文件是否都放进环境里了
   //可以getEnvironment().setRequiredProperties("");进行设置必须的环境配置
   getEnvironment().validateRequiredProperties();
   ```

5. 刷新监听器

   ```java
   // Store pre-refresh ApplicationListeners...
   //存储预刷新应用程序侦听器
   if (this.earlyApplicationListeners == null) {
      this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
   }
   else {
      // Reset local application listeners to pre-refresh state.
      //将本地应用程序侦听器重置为预刷新状态。
      this.applicationListeners.clear();
      this.applicationListeners.addAll(this.earlyApplicationListeners);
   }
   ```

6. 初始化事件集合

   ```java
   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   //允许在Multicast可用后发布早期ApplicationEvents的集合。。。
   this.earlyApplicationEvents = new LinkedHashSet<>();
   ```

## 6.4 加载BeanFactory 

**ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();**

```java
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
   //初始化beanFactory--DefaultListableBeanFactory
   //子类AbstractRefreshableApplicationContext中有实现
   //书上代码5.0时好像没有AbstractRefreshableApplicationContext类，直接在AbstractApplicationCntext中
   refreshBeanFactory();
   return getBeanFactory();//返回不是最终工厂而是配置工厂ConfigurableListableBeanFactory
}
```