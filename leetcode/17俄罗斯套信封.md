# [俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**说明:**
 不允许旋转信封。

> 逻辑就是先排序后寻找
>
> 排序按宽排后再按高排，这样宽升序满足信封套娃条件，要做的就只有找高的最长增长子序列
>
> 最长增长子序列逻辑1：
>
> `新建数组 cell，用于保存最长上升子序列。 `
>
> `  对原序列进行遍历，将每位元素二分插入 cell 中。`  
>
> `   如果 cell 中元素都比它小，将它插到最后 `   
>
> `  否则，用它覆盖掉比它大的元素中最小的那个。`  
>
> `   总之，思想就是让 cell 中存储比较小的元素。这样，cell 未必是真实的最长上升子序列，但长度是对的。`
>
> 
>
> 逻辑一是通过保存较小数，替换较大数实现获取最大增长子序列
>
> 逻辑2：
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/PGmTibd8KQBGcIr3bf70rZWWrgq6Vf937xk0RLgmEXSHXMnqCpOOXic3p7Q3GXYZFHno2icJfLskKse44Jk60cIuA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
>
> ![图片](17%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E4%BF%A1%E5%B0%81-%E6%9C%80%E9%95%BF%E5%A2%9E%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97.assets/640)



```java
 public static int maxEnvelopes(int[][] envelopes) {
       int n = envelopes.length;
       // 按宽度升序排列，如果宽度一样，则按高度降序排列
       Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
       // 对高度数组寻找 LIS
       int[] height = new int[n];
       for (int i = 0; i < n; i++)
           height[i] = envelopes[i][1];

       return lengthOfLIS(height);
   }
   /* 很具小巧思。新建数组 cell，用于保存最长上升子序列。

   对原序列进行遍历，将每位元素二分插入 cell 中。

   如果 cell 中元素都比它小，将它插到最后
   否则，用它覆盖掉比它大的元素中最小的那个。

   总之，思想就是让 cell 中存储比较小的元素。这样，cell 未必是真实的最长上升子序列，但长度是对的。
*/
   public static int lengthOfLIS(int[] nums) {
       int piles = 0, n = nums.length;
       int[] top = new int[n];
       for (int poker : nums) {
           // 要处理的扑克牌
           int left = 0, right = piles;
           // 二分查找插入位置
           while (left < right) {
               int mid = (left + right) / 2;
               if (top[mid] >= poker)
                   right = mid;
               else
                   left = mid + 1;
           }
           if (left == piles) piles++;
           // 把这张牌放到牌堆顶
           top[left] = poker;
       }
       // 牌堆数就是 LIS 长度
       return piles;
   }
```