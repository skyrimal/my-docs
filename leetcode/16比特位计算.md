# [比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

[比特位数计算扩展](https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&mid=2247486495&idx=1&sn=840f5d87a7ed767bdc27b5c97e36bd7e&chksm=fb419f3fcc3616298fafdee1da0baca258be010d2f9827a3afa7ca51a1a0535006bfd89917fb&token=1817572997&lang=zh_CN#rd)

### 取巧

> `Integer.bitCount`获取整形数字的`1`的个数

```java
public int[] countBits(int num) {
    int[] byteOneNums = new int[num+1];
    int length = 0;
    for (int i = 0; i <= num; i++) {
        byteOneNums[i]=Integer.bitCount(i);
    }
    return byteOneNums;
}
```

### 解法1

一个数比如a，如果是偶数，那么a比特位1的个数和(a/2)比特位1的个数是一样的，因为一个数是偶数那么他的二进制比他的一半的二进制只是多了一个0而已。

如果是奇数就不一样了，他会比除以2的结果多了一个1（比如9的二进制比4的二进制多一个1，19的二进制比9的二进制多一个1，等等）。



 ```java
     public static int[] countBits(int num) {
        int[] byteOneNums = new int[num+1];
        for (int i = 0; i <= num; i++) {
//            byteOneNums[i]=byteOneNums[i/2]+(i & 1);
            byteOneNums[i]=byteOneNums[i>>1]+(i & 1);//i>>1右移两位，跟/2一个效果
        }
        return byteOneNums;
    }
 ```



### 解法2

上面说了一个数如果是偶数那么他的比特位个数和他一半的比特位数量是一样的，但奇数会加1。

思考这样一个问题，8-15中的每个数的比特位的个数比对应的0-7多一个1，举个例子8（1000）比0（0）多一个1，15（1111）比7（111）多一个1。

同理16-31中的每个数的比特位个数比0-15多了一个1

```java
//按一解反向思考，每扩大一倍，比特数为当前已有的比特数加1，即每2的n次方一个循环
public static int[] countBits(int num) {
    int[] byteOneNums = new int[num+1];
    int bound = 1;//保存2次方循环的边界
    for (int i = 1; i <=num ; i++) {
        if(i>>1==bound)bound<<=1;
        byteOneNums[i]=byteOneNums[i-bound]+1;
    }
    return byteOneNums;
}
```

### 解法3

大家还记得位运算中`i & (i - 1)`是什么意思吗，其实就是**消掉二进制位中最右边的1**，

> 即找到当前要计算的`i`**少一个`1`的数**

![image.png](16%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E7%AE%97.assets/1614735024-TCFgvq-image.png)

```java
	public int[] countBits(int num) {
        int[] bits = new int[num + 1];
        for (int i = 1; i <= num; ++i) bits[i] = bits[i & (i - 1)] + 1;
        return bits;
    }

```

