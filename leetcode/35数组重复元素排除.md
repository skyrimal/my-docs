# [ 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```



```java
/*
    同逻辑大佬代码
    同数组位移，当连续两次重复出现后向前移，最后形成新数组
    i为新数组的指针
    public int removeDuplicates(int[] nums) {
        int i = 0;
        for (int n : nums)
            if (i < 2 || n > nums[i-2]) nums[i++] = n;
        return i;
    }
     */

    //1,1,1,1,2,2,2,3,4
    //0,1,2,3,4,5,6,7,8
    public int removeDuplicates(int[] nums) {
        //窗口扩展，每当窗口内相同元素大于2则记录序号和一个跳跃间隔
        int length = nums.length;
        //记录序号和一个跳跃间隔的容器
        int[] jump = new int[length];

        //初始化窗口，容纳超过2的部分
        int point = 0, size = 1, value = nums[0];
        for (int i = 1; i < length; i++) {
            //普通情况下每个序号跳跃间隔赋值
            if (size < 3) jump[i] = jump[i - 1];//一次
            if (nums[i] == value) size++;
            //指向窗口最左，i为窗口右边界，每次都应该指向上一次跳跃结果后
            if (size == 3) point = i - jump[point]-1;

            //当窗口容纳下一个元素时，给每个序号跳跃间隔赋值
            if (nums[i] != value) {
                //jump最后一个保存的是最大跳跃间隔，也就是被跳过的元素的个数
                for (int j = point; j < i && size > 2; j++)
                    jump[j] = jump[point - 1] + (size - 2);
                jump[i] = jump[i - 1];
                //重新初始化窗口
                value = nums[i];
                size = 1;
            }
        }

        //当只有一种元素时无法记录跳跃间隔，在这里兜底
        if( size > 2){
            for (int j = point; j < length; j++) jump[j] = jump[point - 1] + (size - 2);
        }

        //nums每个元素都进行跳跃
        int jumpSize = length - jump[length - 1];//跳跃完成后的数组大小,没有发生跳跃时不能+1
        for (int i = 0; i < jumpSize; i++) {
            nums[i] = nums[i + jump[i]];
        }

        return jumpSize;
    }
```

