

# [132模式](https://leetcode-cn.com/problems/132-pattern/)

给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 a**i**, a**j**, a**k** 被定义为：当 **i** < **j** < **k** 时，a**i** < a**k** < a**j**。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

**注意：**n 的值小于15000。

### 解题思路

132可以进行分解

将1<3<2条件分解为 1<2 1<3 3<2 的交集

然后我们先获取1<2的边界值,即对序号i的数字来说，数组0到i中的最小值，然后当最小值小于当前值时满足基础条件1<2
在满足1<2的集合中寻找是否有满足3<2&&1<3的情况



### 代码逻辑

1. 重复比较获取每个数对应的当前最小值，保存到numsmins数组中
2. 遍历nums判断是否满足nums[i]>numsmins[i]，即判1<2、1<3，栈为空时将当前数字入栈，入栈的相当于3
3. 将numsmins[i]与栈顶比较，当栈顶小于等于当前数字对应最小值时，出栈；即收缩范围去除1>=3的范围，寻找1<2时1<3的边界值（到目前为止）
4. 栈顶与当前数字比较，满足栈顶小于num[i]，即满足3<2条件
5. 综上所述，最后返回时即存在满足 1<3<2 的元素





```java
public boolean find132pattern(int[] nums) {
        //1.获取每一个数字前最小的数，找完后序号越大，最小值就越小
        //2.反向遍历入栈，不满足条件直接出栈，入栈的时132的2
        /*
        * 反向遍历的条件，
        * 理解加深，min即为1，当前nums为2，栈内为3
        * */
        int len = nums.length;
        int[] numsmins=new int[len];
        numsmins[0]=nums[0];
        for (int i = 1; i < len; i++) {
            numsmins[i]=Math.min(numsmins[i-1],nums[i]);//保守每一个数前最小数
        }
    //反向遍历 特别注意，numsmin反向遍历是递增趋势
    Stack<Integer> stack = new Stack<>();
    for (int i = len-1; i >=0; i--) {
        if(nums[i]>numsmins[i]){//可能满足2>1的元素

            //当不能满足2>1时丢弃,即2过小时
            while (!stack.isEmpty()&&stack.peek()<=numsmins[i]){//比当前的min还小的化那比之后的min相差会更大
                stack.pop();
            }
            //循环后的栈顶必定满足[i,len-1]的1<2条件
            //当满足2<3时返回true
            if(!stack.isEmpty()&&stack.peek()<nums[i]){
                return true;
            }

            stack.push(nums[i]);
        }
    }
    return false;

```
