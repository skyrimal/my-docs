# [验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

```
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```

例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。 

>二叉树的槽位，每当添加一个节点就会填补上个节点的槽位并新增两个空的槽位
>
>所有的槽位都为2时为一个满二叉树

```java
public boolean isValidSerialization(String preorder) {
        if(preorder.equals("#")) return true;
        // 槽位处理法，
        // 按顺序每增加一个节点，则代表上一个节点的空槽被补充，
        // 补满后再补充的就是上一个节点的槽位
        Deque<Integer> stack = new LinkedList<>();
        int length = preorder.length();
        for (int i = 0; i < length; i++) {
            char c = preorder.charAt(i);
            if(c==','){
                continue;
            }
            if(c!='#'){
                 while (i + 1 < length && (preorder.charAt(i + 1) != '#' && preorder.charAt(i + 1) != ',')) i++;
                 if(stack.size()>0) {
                    if (stack.peek()-1==0) stack.pop();
                    else stack.push(stack.pop() - 1);
                }
                stack.push(2);
                continue;
            }

            if (stack.size() > 0) {
                if (stack.peek() - 1 == 0) {
                    stack.pop();
                    if(stack.size()==0&&i<length-1) return false;
                }
                else stack.push(stack.pop() - 1);
            } else {
                return false;
            }
        }
        return stack.size()==0;
    }
```

