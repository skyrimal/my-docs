# [笨阶乘](https://leetcode-cn.com/problems/clumsy-factorial/)

通常，正整数 `n` 的阶乘是所有小于或等于 `n` 的正整数的乘积。例如，`factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1`。

相反，我们设计了一个笨阶乘 `clumsy`：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。

例如，`clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1`。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。

另外，我们使用的除法是地板除法（*floor division*），所以 `10 * 9 / 8` 等于 `11`。这保证结果是一个整数。

实现上面定义的笨函数：给定一个整数 `N`，它返回 `N` 的笨阶乘。



## 公式推导

因为题中的运算顺序是乘法(*)，除法(/)，加法(+)和减法(-)，比如10*9/8+7-6，我们先不看后面的减法，直接看前面的3项，也就是n*(n-1)/(n-2)，我们来分析一下这个公式，如下图所示

![597e6179e4fc426b69d2a12ea9db016.jpg](34%E6%87%92%E4%B9%98%E9%98%B6.assets/1617241963-BQGMiI-597e6179e4fc426b69d2a12ea9db016.jpg)

通过上面的分析我们发现，当n>4的时候，n*(n-1)/(n-2)就等于n+1，但当n小于等于4的时候我们要分开讨论，很明显

    n=4的时候，结果是7
    n=3的时候，结果是6
    n=2的时候，结果是2
    n=1的时候，结果是1


当n大于4的时候我们要展开讨论

1，n%4==0

比如n=12，
![image.png](34%E6%87%92%E4%B9%98%E9%98%B6.assets/1617243261-TcfSHf-image.png)

2，n%4==1

比如n=13，

![image.png](34%E6%87%92%E4%B9%98%E9%98%B6.assets/1617243155-TZYQJv-image.png)


3，n%4==2

比如n=14，

![image.png](34%E6%87%92%E4%B9%98%E9%98%B6.assets/1617243161-zPpzck-image.png)


4，n%4==3

比如n=15，

![image.png](34%E6%87%92%E4%B9%98%E9%98%B6.assets/1617243145-sStBrX-image.png)

变化规律为{n+1,n+2,n+2,n-1}

```java
/*

    大佬代码，总结数学规律后的代码
    当n>4的时候，n*(n-1)/(n-2)就等于n+1，但当n小于等于4的时候我们要分开讨论，很明显

    n=4的时候，结果是7
    n=3的时候，结果是6
    n=2的时候，结果是2
    n=1的时候，结果是1

    public int clumsy(int n) {
        int[] special = new int[]{1,2,6,7};
        int[] diff = new int[]{1,2,2,-1};
        if (n <= 4) return special[(n - 1) % 4];
        return n + diff[n % 4];
    }
*/

    int action=0;//方法
    Stack<Integer> s = new Stack<>();
    //简化后
    public int clumsy(int n) {
        s.push(n);
        for (int i = n-1; i >0 ; i--) {
            method(i);
            action=(action+1)%4;//循环计数法
        }

        int reNum=s.pop();
        while (!s.isEmpty()) reNum+=s.pop();

        return reNum;
    }

    private void method(int num){
        switch (action){
            case 0:
                s.push(s.pop()*num);
                return;
            case 1:
                s.push(s.pop()/num);
                return;
            case 2:
                s.push(num);
                return;
            case 3:
                s.push(-num);//这样下一组乘除法返回为负数
        }
    }
/*    int mathMethod=0;//0123 * /+-
    public int clumsy(int n) {
        int sum = 0;
        int num=n;
        Stack<Integer> s = new Stack<>();
        for (int i = n-1; i >0 ; i--) {
            if(mathMethod==3){//直接保存正数
                sum+=i;
                mathMethod++;
                continue;
            }
            if(mathMethod==4){//作用是初始化重新进行新循环计算
                num=i;
                mathMethod=0;
                continue;
            }
            num=mathAction(num,i);
            if(mathMethod==2){//保存乘除后的树
                s.push(num);
                num=0;
                mathMethod++;
            }
        }
        s.push(num);

        //栈中除了第一个是正数外，其他都是负数
        while(s.size()!=1){
            sum-=s.pop();
        }
        sum+=s.pop();
        return sum;
    }

    private int mathAction(int num1,int num2){
        switch (mathMethod){
            case 0:
                mathMethod++;
                return num1*num2;
            case 1:
                mathMethod++;
                return num1/num2;
            default: return -1;
        }
    }*/
```