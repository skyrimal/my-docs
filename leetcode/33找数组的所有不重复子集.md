

# [子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

```java
	public List<List<Integer>> subsetsWithDup(int[] nums) {
        //对普通数组按照题意，可以先排序后遍历
        bubbleSort(nums);
        Set<List<Integer>> reSet = new HashSet<>();
        List<Integer> cur = new ArrayList<>();
        recursiveTraversal(nums,cur,0,reSet);
        return new ArrayList<>(reSet);
    }

    //递归遍历法 遍历所有不重复数组子集 recursive traversal
    private void recursiveTraversal(int[] nums,List<Integer> cur,int num,Set<List<Integer>> content){
        if(nums.length==num){//所有位置都决策完成，将当前方案放入结果集
            content.add(new ArrayList<>(cur));//拷贝cur当前的快照
            return;
        }
        cur.add(nums[num]);//保存当前元素时的情况，往下决策
        recursiveTraversal(nums,cur,num+1,content);

        cur.remove(cur.size()-1);//不保存当前元素的情况，往下决策
        recursiveTraversal(nums,cur,num+1,content);
    }

    //冒泡排序--升序
    private void bubbleSort(int[] nums) {
        //大的放后面
        for (int i = 0; i < nums.length; i++) {
            for (int j = 1; j < nums.length - i; j++) {
                if (nums[j] < nums[j - 1]) {
                    changeNum(nums, j);
                }
            }
        }
    }

    private void changeNum(int[] nums, int j) {
        int temp = nums[j];
        nums[j] = nums[j - 1];
        nums[j - 1] = temp;
    }
```



### 遍历数组所有子集—递归法

每一次递归都会对当前方法进行快照

下面的逻辑可以用树形理解，每个元素都有保存和不保存两种状态，下面递归则是遍历整个树

```java
//递归遍历法 遍历所有不重复数组子集 recursive traversal
private void recursiveTraversal(int[] nums,List<Integer> cur,int num,Set<List<Integer>> content){
    if(nums.length==num){//所有位置都决策完成，将当前方案放入结果集
        content.add(new ArrayList<>(cur));//拷贝cur当前的快照
        return;
    }
    cur.add(nums[num]);//保存当前元素时的情况，往下决策
    recursiveTraversal(nums,cur,num+1,content);

    cur.remove(cur.size()-1);//不保存当前元素的情况，往下决策
    recursiveTraversal(nums,cur,num+1,content);
}
```