## [数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

给定一个非空且只包含非负数的整数数组 nums，数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。



1.首先分析题意知，需要返回的是**度最大时元素的最小子数组长度**

2.按照逻辑，可知当一个子数组**左右元素相同时**为某元素某度的最小子数组

3.1、2可得，只要记录每次**度变大/不变时**的元素位置减去该元素**初次出现**的位置则可获取最大度的最小子数组



操作：

	1. 记录每个元素的***度***==》**win**
 	2. 记录每个***元素初次出现的位置***==》**lps**
 	3. 通过**lps**记录每个度的***最小数组长度***==》**winLen**
 	4. 找到***最大度*****max**并通过最大度在**winLen**取出该度对应**最小数组长度**

```java
	public int findShortestSubArray(int[] nums) {
        int length = nums.length;
        if(length==1){//排除只有一个元素的情况
            return length;
        }
        //每个元素的度窗口字典
        int[] win = new int[50*1000];
        //每个元素的最左坐标
        int[] lps = new int[50*1000];
        Arrays.fill(lps,-1);
        //每个度对应的最小数组长度
        int[] winLen = new int[50*1000];
        Arrays.fill(winLen,winLen.length);
        int max = 0;//最大度
        lps[nums[0]] = 0;

        for (int rp = 0; rp < length; rp++) {
            if(lps[nums[rp]]==-1) lps[nums[rp]]=rp;//记录探索到的每一个元素的位置
            win[nums[rp]]++;
            //度大于等于时判断元素在该度的长度
            if(win[nums[rp]]>=max){
                max = win[nums[rp]];
                winLen[max] = Math.min(rp-lps[nums[rp]]+1,winLen[max]);
            }
        }

        return winLen[max];
    }
```

