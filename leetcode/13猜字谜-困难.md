# [猜字谜](https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/)

>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。
>
>字谜的迷面 `puzzle` 按字符串形式给出，如果一个单词 `word` 符合下面两个条件，那么它就可以算作谜底：
>
>- 单词 `word` 中包含谜面 `puzzle` 的第一个字母。
>- 单词 `word` 中的每一个字母都可以在谜面 `puzzle` 中找到。
>   例如，如果字谜的谜面是 "abcdefg"，那么可以作为谜底的单词有 "faced", "cabbage", 和 "baggage"；而 "beefed"（不含字母 "a"）以及 "based"（其中的 "s" 没有出现在谜面中）。
>
>返回一个答案数组 `answer`，数组中的每个元素 `answer[i]` 是在给出的单词列表 `words` 中可以作为字谜迷面 `puzzles[i]` 所对应的谜底的单词数目。

## 解法1，二进制压缩法

一直谜面字符为有限的26个小写字母，所以谜面可以压缩进26位的二进制（0101010101）中

本题选用int（4字节32位）来保存压缩结果（处理时想象成0101型的二进制），结果集放入HashMap中

处理步骤：：

1. 压缩所以的word
2. 遍历puzzle的压缩后的子集
3. 遍历puzzle子集时要注意，按照题意必须包含puzzle的第一个字母，所以遍历的是必定包含第一个字母的puzzle二进制子集
4. 怎么遍历二进制没看懂

```java
public static List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {
    //二进制压缩法压缩字符串
    //小写字母有26个，所以本题所有的字符串都可以压缩为一个长26的二进制数组
    //这里把int充做32位二进制数组
    Map<Integer, Integer> frequency = new HashMap<>();
    //开始对words进行压缩
    for (String word : words) {
        int mask = 0;
        char[] wordChars = word.toCharArray();
        for (char wordChar : wordChars) {
            //'|='作用：两个二进制对应位为0时该位为0，否则为1
            //'<<'作用，向右移动到字母指定位置
            mask |= 1 << wordChar - 'a';
        }
        frequency.put(mask, frequency.getOrDefault(mask, 0) + 1);//相同的word保存到相同的位置
    }

    //同法压缩puzzles，并遍历子集
    List<Integer> ans = new ArrayList<Integer>();
    for (String puzzle : puzzles) {

        int total = 0;
        int mask = 0;
        char[] puzzleChars = puzzle.toCharArray();
        int length = puzzleChars.length;

        for (int i = 1; i < length; i++) {
            mask |= 1 << puzzleChars[i] - 'a';//保存除了首位的压缩结果，应为首位为条件必须存在
        }


        int subset = mask;//赋值后动态改变，达到遍历子集的作用
        do{
            int s = subset | (1 << (puzzle.charAt(0) - 'a'));
            if (frequency.containsKey(s)) {
                total += frequency.get(s);
            }
            System.out.println(Integer.toBinaryString(subset));
            subset = (subset - 1) & mask;//可以遍历所有二进制子集
        } while (subset != mask);//执行逻辑后，判断条件，再循环
        ans.add(total);
    }
    return ans;
}
```

补充，二进制子集的遍历方法

```java
		//实现了 int mask 的二进制子集遍历
		int subset = mask;//赋值后动态改变，达到遍历子集的作用
        do{
            System.out.println(Integer.toBinaryString(subset));
            subset = (subset - 1) & mask;//可以遍历所有二进制子集
        } while (subset != mask);//执行逻辑后，判断条件，再循环
```

## 解法2，字典树法

将word改为字符集合排序后放入树中，