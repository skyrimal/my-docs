```
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：
* <p>
* 实现 MyQueue 类：
* <p>
* void push(int x) 将元素 x 推到队列的末尾
* int pop() 从队列的开头移除并返回元素
* int peek() 返回队列开头的元素
* boolean empty() 如果队列为空，返回 true ；否则，返回 false
```

```java

class MyQueue {
    private final Stack<Integer> storageStack;
    private final Stack<Integer> utilStack;

    /**
     * Initialize your data structure here.
     */
    public MyQueue() {
        storageStack = new Stack<>();
        utilStack = new Stack<>();
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        storageStack.push(x);
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        //1.装进utilStack
        while (!storageStack.empty()){
            utilStack.push(storageStack.pop());
        }
        //2.取出utiStack的栈顶
        int popInt = utilStack.pop();
        //3.装回storStack
        while (!utilStack.empty()){
            storageStack.push(utilStack.pop());
        }
        return popInt;
    }

    /**
     * Get the front element.
     */
    public int peek() {
        //1.装进utilStack
        while (!storageStack.empty()){
            utilStack.push(storageStack.pop());
        }
        //2.取出utiStack的栈顶
        int peekInt = utilStack.peek();
        //3.装回storStack
        while (!utilStack.empty()){
            storageStack.push(utilStack.pop());
        }
        return peekInt;
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        if (storageStack==null) return true;
        return storageStack.size() == 0;
    }

}
```