# [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

给你一个 `m x n` 的矩阵 `matrix` 和一个整数 `k` ，找出并返回矩阵内部矩形区域的不超过 `k` 的最大数值和。

题目数据保证总会存在一个数值和不超过 `k` 的矩形区域。

 

**示例 1：**

![img](37%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.assets/sum-grid.jpg)

```
输入：matrix = [[1,0,1],[0,-2,3]], k = 2
输出：2
解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
```

## 宫水三叶 永远的神

### 1

从题面来看显然是一道「二维前缀和」的题目，如果你还不了解「二维前缀和」，可以看看 （题解）304. 二维区域和检索 - 矩阵不可变。本题预处理前缀和的复杂度为 O(m∗n)O(m * n)O(m∗n)。

搜索所有子矩阵需要枚举「矩形左上角」和「矩形右下角」，复杂度是 O(m2∗n2)O(m^2 * n^2)O(m2∗n2)。

因此，如果把本题当做二维前缀和模板题来做的话，整体复杂度是 O(m2∗n2)O(m^2 * n^2)O(m2∗n2)。

数据范围是 10210^2102，对应的计算量是 10810^8108，理论上会超时，但当我们枚举「矩形左上角」(i,j)(i,j)(i,j) 的时候，我们只需要搜索位于 (i,j)(i,j)(i,j) 的右下方的点 (p,q)(p,q)(p,q) 作为「矩形右下角」，所以其实我们是取不满 m2∗n2m^2 * n^2m2∗n2 的，但仍然具有超时风险（2021/04/20 Java 测试可通过，C++ 使用 vector 会 TLE）。

### 2

前缀和 & 二分（抽象一维）

我们来细想一下「朴素二维前缀和」解法是如何搜索答案（子矩阵）：通过枚举「左上角」&「右下角」来唯一确定某个矩阵。

换句话说是通过枚举 (i,j)(i,j)(i,j) 和 (p,q)(p,q)(p,q) 来唯一确定子矩阵的四条边，每个坐标点可以看作确定子矩阵的某条边。

既然要确定的边有四条，我们可以如何降低复杂度呢？

简单的，我们先思考一下同样是枚举的 1. 两数之和 问题。

在 1. 两数之和 中可以暴力枚举两个数，也可以只枚举其中一个数，然后使用数据结构（哈希表）来加速找另一个数（这是一个通用的「降低枚举复杂度」思考方向）。

对应到本题，我们可以枚举其中三条边，然后使用数据结构来加速找第四条边。

当我们确定了三条边（红色）之后，形成的子矩阵就单纯取决于第四条边的位置（黄色）：

image.png

于是问题转化为「如何快速求得第四条边（黄色）的位置在哪」。

我们可以进一步将问题缩小，考虑矩阵只有一行（一维）的情况：

image.png

这时候问题进一步转化为「在一维数组中，求解和不超过 K 的最大连续子数组之和」。

对于这个一维问题，我们可以先预处理出「前缀和」，然后枚举子数组的左端点，然后通过「二分」来求解其右端点的位置。

假定我们已经求得一维数组的前缀和数组 sum，即可得下标范围 [i,j][i,j][i,j] 的和为：

areaSum(i,j)=sum[j]−sum[i−1]⩽kareaSum(i, j) = sum[j] - sum[i - 1] \leqslant k areaSum(i,j)=sum[j]−sum[i−1]⩽k

经过变形后得：

sum[j]⩽k+sum[i−1]sum[j] \leqslant k + sum[i - 1] sum[j]⩽k+sum[i−1]

我们有两种思路来最大化 areaSum(i,j)areaSum(i, j)areaSum(i,j)：

    确定（枚举）左端点位置 i，求得符合条件的最大右端点 sum[j]
    确定（枚举）右端点位置 j，求得符合条件的最小左端点 sum[i]

对于没有负权值的一维数组，我们可以枚举左端点 i，同时利用前缀和的「单调递增」特性，通过「二分」找到符合 sum[j]⩽k+sum[i−1]sum[j] \leqslant k + sum[i - 1]sum[j]⩽k+sum[i−1] 条件的最大值 sum[j]，从而求解出答案。

但是如果是含有负权值的话，前缀和将会丢失「单调递增」的特性，我们也就无法使用枚举 i 并结合「二分」查找 j 的做法。

这时候需要将过程反过来处理：我们从左到右枚举 j，并使用「有序集合」结构维护遍历过的位置，找到符合 sum[j]−k⩽sum[i]sum[j] - k \leqslant sum[i]sum[j]−k⩽sum[i] 条件的最小值 sum[i]，从而求解出答案。

基于上述分析，解决这样的一维数组问题复杂度是 O(nlog⁡n)O(n\log{n})O(nlogn) 的。

将这样的思路应用到二维需要一点点抽象能力。

同时，将一维思路应用到本题（二维），复杂度要么是 O(m2∗nlog⁡n)O(m^2 * n\log{n})O(m2∗nlogn) 要么是 O(n2∗mlog⁡m)O(n^2 * m\log{m})O(n2∗mlogm)。

我们先不考虑「最大化二分收益」问题，先假设我们是固定枚举「上下行」和「右边列」，这时候唯一能够确定一个子矩阵则是取决于「左边列」：

439B50D739F1D963EB2460394C5689B5.png

重点是如何与「一维」问题进行关联：显然「目标子矩阵的和」等于「子矩阵的右边列 与 原矩阵的左边列 形成的子矩阵和」-「子矩阵左边列 与 原矩阵左边列 形成的子矩阵和」

我们可以使用 area[r] 代表「子矩阵的右边列 与 原矩阵的左边列 形成的子矩阵和」，使用 area[l - 1] 代表「子矩阵的左边列 与 原矩阵的左边列 形成的子矩阵和」的话，则有：

target=area[r]−area[l−1]⩽ktarget = area[r] - area[l - 1] \leqslant k target=area[r]−area[l−1]⩽k

这与我们「一维问题」完全一致，同时由「上下行」&「右边列」可以直接确定 area[r] 的大小，通过「有序集合」存储我们遍历 r 过程中的所有的 area[r] 从而实现「二分」查找符合 area[r]−k⩽area[l−1]area[r] - k \leqslant area[l - 1]area[r]−k⩽area[l−1] 条件的 最小 的 area[l - 1]。

至此，我们通过预处理前缀和 + 容斥原理彻底将题目转化为「一维问题」进行来求解。





```java

//按条件判断是上下用二分法还是左右用二分法
public int maxSumSubmatrix(int[][] mat, int k) {
    int m = mat.length, n = mat[0].length;
    int[][] sum = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1];
        }
    }
    // 固定的是否为右边界
    //宽d大于高，方法不变，高大于宽，遍历左右边界，对上下边界用二分法，
    boolean isRight = n > m;
    int ans = Integer.MIN_VALUE;
    for (int i = 1; i <= (isRight ? m : n); i++) {
        for (int j = i; j <= (isRight ? m : n); j++) {
            TreeSet<Integer> ts = new TreeSet<>();
            ts.add(0);
            for (int fixed = 1; fixed <= (isRight ? n : m); fixed++) {
                int a = isRight ? sum[j][fixed] - sum[i - 1][fixed] : sum[fixed][j] - sum[fixed][i - 1];
                Integer b = ts.ceiling(a - k);
                if (b != null) {
                    int cur = a - b;
                    ans = Math.max(ans, cur);
                }
                ts.add(a);
            }
        }
    }
    return ans;
}


//二分法，
//遍历上下边界，
//当上下边界固定时，再横向从左到右遍历前缀和，以实现遍历全部矩形
//横向遍历时，将遍历到的前缀和存进树中等待判断
//当树中所有前缀和中存在与当前 前缀和 和k只相差最小的
public int maxSumSubmatrix(int[][] mat, int k) {
    int m = mat.length, n = mat[0].length;

    // 预处理前缀和
    int[][] sum = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1];
        }
    }

    int ans = Integer.MIN_VALUE;
    // 遍历子矩阵的上边界
    for (int top = 1; top <= m; top++) {
        // 遍历子矩阵的下边界
        for (int bot = top; bot <= m; bot++) {
            // 使用「有序集合」维护所有遍历到的右边界
            TreeSet<Integer> ts = new TreeSet<>();
            ts.add(0);
            // 遍历子矩阵的右边界
            for (int r = 1; r <= n; r++) {
                // 通过前缀和计算 right
                int right = sum[bot][r] - sum[top - 1][r];
                // 通过二分找 left
                // 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。
                Integer left = ts.ceiling(right - k);
                if (left != null) {
                    int cur = right - left;
                    ans = Math.max(ans, cur);
                }
                // 将遍历过的 right 加到有序集合
                ts.add(right);
            }
        }
    }
    return ans;
}

//1.暴力解法
public int maxSumSubmatrix(int[][] mat, int k) {
    int m = mat.length, n = mat[0].length;
    int[][] sum = new int[m + 1][n + 1];//状态法扩张基础大小
    //二维前缀和
    //遍历左上角到右下角扩张的每个位置的坐标，相当于找到所有右下坐标
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]
                    + mat[i - 1][j - 1];//状态原比状态小1
        }
    }
    int ans = Integer.MIN_VALUE;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            //每一个二维前缀和只要减去遍历的固定部分就可以遍历所有的二维矩形面积
            for (int p = i; p <= m; p++) {
                for (int q = j; q <= n; q++) {
                    int cur = sum[p][q] - sum[i - 1][q] - sum[p][j - 1] + sum[i - 1][j - 1];
                    if (cur==k) return cur;//之后就无意义了
                    if (cur < k) {
                        ans = Math.max(ans, cur);
                    }
                }
            }

        }
    }
    return ans;
}
```