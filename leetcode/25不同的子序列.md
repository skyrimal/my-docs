# [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

题目数据保证答案符合 32 位带符号整数范围。



参考青蛙跳台阶，不同之处在于台阶的值改变需要特定条件

执行状态传递时，将`T`中的字符当作一个个**台阶**，将`s`中的字符当成一只只的**青蛙**

每次一只青蛙跳上台阶，当***青蛙发现台阶上有他的画像***时，***青蛙则改变当前台阶的值***

`跳台阶值改变方法为上个台阶的值加上当前台阶的值，计算的值留着当前台阶`

这样当最后一只青蛙跳上台阶后，最后一个台阶的值则为所有台阶都满足条件的次数

```java
public int numDistinct(String s, String t) {
    int m=s.length(),n = t.length();
    if(m<n) return 0;
    //初始化为1，用来填补台阶
    int[][] status = new int[m+1][n+1];
    for (int i = 0; i < m; i++) {
        status[i][0]=1;
    }
    for (int i = 0; i < m; i++) {
        //台阶思想 总数为上一个台阶及之前的总数+最后一个台阶的数目
        //每一次遍历都会更新每一个台阶的值
        //只有满足条件才会累加上一个台阶的值，不满足条件台阶则继承上一次
        //按照上述逻辑，只有s的子串每个字符都满足在t中顺序出现时，才会继承状态
        char c = s.charAt(i);
        for (int j = 0; j < n; j++) {
            //当相等时，台阶的值进行累加
            if(c==t.charAt(j))
                status[i+1][j+1]=status[i][j]+status[i][j+1];
            //当不相等时，继承上一次台阶的值
            else
                status[i+1][j+1]=status[i][j+1];
        }
    }
    return status[m][n];
}
```