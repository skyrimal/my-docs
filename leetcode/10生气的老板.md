# [1052. 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)

>今天，书店老板有一家店打算试营业 `customers.length` 分钟。每分钟都有一些顾客（`customers[i]`）会进入书店，所有这些顾客都会在那一分钟结束后离开。
>
>在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。
>
>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `X` 分钟不生气，但却只能使用一次。
>
>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。

由题意反向思考可知，只要不生气时顾客最多则满足题意

1.创建一个大小为x的窗口

2.初始化窗口记录0-x的生气顾客数

3.移动窗口，当窗口右边界触碰到`grumpy[i]==1` 时增大customers[i]，当窗口左边界碰到 `grumpy[i] ==1`时减小customers[i-x]

4.移动窗口时，如果窗口变大，则记录窗口边界lp(左指针)、rp(右指针)

5.遍历累加customers,当遍历到最大生气窗口区间时不判断grumpy[i]是否等于1

```java
 public static int maxSatisfied(int[] customers, int[] grumpy, int x) {
        //表面看是找最大，实际上按题意可以创建一个容量为x窗口，找窗口内最大值
        int length = customers.length;
        //初始化一个只记录生气的窗口
        int lp = 0, rp = x - 1, win = 0;
        for (int i = 0; i < x; i++) if (grumpy[i] == 1) win += customers[i];
        int maxSize = win;
        for (int i = x; i < length; i++) {
            //移动窗口时只管增删生气的部分
            if (grumpy[i] == 1) win += customers[i];
            if (grumpy[i - x] == 1) win -= customers[i - x];
            //记录指针
            if (maxSize<win) {
                maxSize=win;
                lp = i - x + 1;
                rp = i;
            }
        }
        int serveCustomers = 0;
        for (int i = 0; i < length; i++) {
            if((i>=lp&&i<=rp)) serveCustomers+=customers[i];
            else if(grumpy[i]!=1) serveCustomers+=customers[i];
        }
        return serveCustomers;
    }
```

