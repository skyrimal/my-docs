# [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

给你单链表的头节点 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

1.首先要找回单链表，所以首节点绝对地址不能丢失

2.按照题意，可以通过 指针 和 .next() 方法进行快速遍历

3.当遍历到左边起点 left 时开始将节点入栈，并记录入栈前一个节点的地址

记录地址要判断是否为节点的边界，我代码没写好，应该是左右边界指针指向null才对

4.当入栈完成后，记录 next 为右边界的指针

5.通过出栈生成一条新的链表（这里注意，因为是按顺序入栈，所以新的链表是首尾相连的）

6.将左右指针与新链表进行连接，要注意左指针为空的话连接后就不是原 head

```java
	public ListNode reverseBetween(ListNode head, int left, int right) {
               if(left==right) return head;
        //从第 left 个开始，到 right 个共 right-left+1 个 节点进行翻转
        //两个指针分别指向截断区域的两端，两端为第 left-1 和第 right+1 个，所以要判断两端是否越界，越界时指向null就好，翻转后拼接通过是否为null判断是否拼接
        //移动指针寻找截断区域两端的同时，将要翻转的区域放入栈中，再从栈中取出实现翻转，最后进行拼接
        ListNode nodePoint = head, lp = head, rp = head;
        int platePoint = 1;//表示第几个，head就是第一个
        Stack<ListNode> nodeStack = new Stack<>();
        if (left == 1) lp = null;
        while (true) {
            if (platePoint == left - 1) {
                lp = nodePoint;//保存左指针
            }
            if (platePoint == right + 1) {
                rp = nodePoint;//保存左指针
            }
            if (platePoint >= left && platePoint <= right) {
                nodeStack.push(nodePoint);
            }
            if (nodePoint.next != null) {
                nodePoint = nodePoint.next;
                platePoint++;
            } else {
                break;
            }
        }
        if(platePoint==right) rp=null;
        ListNode newHead = new ListNode();
        ListNode tail = newHead;//移动添加，最后指向链尾
        while (nodeStack.size() != 0) {
            tail.next = nodeStack.pop();
            tail = tail.next;
        }
        if (lp != null) lp.next = newHead.next;
        else head = newHead.next;
        tail.next = rp;
        return head;
    }
```

