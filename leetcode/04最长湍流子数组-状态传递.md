# [978. 最长湍流子数组](https://leetcode-cn.com/problems/longest-turbulent-subarray/)

>当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：
>
>    若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
>    或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。
>
>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。
>
>返回 A 的最大湍流子数组的长度。
>



状态的定义：

    定义 up[i] 表示以位置 i 结尾的，并且 arr[i - 1] < arr[i] 的最长湍流子数组长度。
    定义 down[i] 表示以位置 i 结尾的，并且 arr[i - 1] > arr[i] 的最长湍流子数组长度。

up[i] 和 down[i] 初始化都是 1，因为每个数字本身都是一个最小的湍流子数组。
状态转移方程：

    up[i] = down[i - 1] + 1，当 arr[i - 1] < arr[i]；
    down[i] = up[i - 1] + 1，当 arr[i - 1] > arr[i]；

解释：湍流子数组的增长和降低是交替的。

![978.gif](C:%5CUsers%5CAdministrator%5CDesktop%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%5Cmd%5C%E5%90%8E%E7%AB%AF%5Cleecode%5C2021%5CUntitled.assets%5C1612746849-AHrNUH-978.gif)

```java
public static int maxTurbulenceSize(int[] arr){
    int length = arr.length;
    //通过up/down记录变大变小的状态，并通过交替传递状态
    int maxCount = 1;
    int[] up=initArr(length);
    int[] down=initArr(length);
    for (int i = 1; i < length; i++) {
        //由题意可知，变大变小会累加，相等则会初始化计数为1
        if(arr[i]>arr[i-1]) {
            up[i] = down[i - 1]+1;
            maxCount=Math.max(maxCount,up[i]);
        }
        if(arr[i]<arr[i-1]){
            down[i]=up[i-1]+1;
            maxCount=Math.max(maxCount,down[i]);
        }
    }
    return maxCount;
}

public static int[] initArr(int length){
    int[] arr=new int[length];
    for (int i = 0; i < length; i++) {
        arr[i]=1;
    }
    return arr;
}
```