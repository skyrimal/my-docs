# [分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

>给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。
>
>返回符合要求的 **最少分割次数** 。

1.0-i范围只要为true则表示不用切割，出现false则进行切割

2.切割后以i为有边界，反向循环扩大窗口进行判断，

3.扩大窗口时：当出现窗口扩大为回文，则切割次数为窗口边界的上一次切割数+1

4.扩大窗口时：当窗口再次为回文时（扩大到包含上次发现的回文），切割次数依当前窗口边界的上一次切割数+1

。。。

```java
public static int minCut(String s) {
    int length = s.length();
    if(length<2) return 0;
    char[] chars = s.toCharArray();
    //1.动态传递法判断是否为回文
    boolean[][] flag = new boolean[length][length];
    for (int pr = 0; pr < length; pr++) {
        for (int pl = pr; pl >=0; pl--) {
            //每次左指针回调时必定为true
            if(pl==pr){
                flag[pl][pr]=true;
                continue;
            }
            //当前回文长为2时，即判断回文长度为偶数情况时的初始状态
            if(pr-pl==1){
                flag[pl][pr]=chars[pr]==chars[pl];
                continue;
            }
            flag[pl][pr]=flag[pl+1][pr-1]&&chars[pl]==chars[pr];
        }
    }
    int[] fp =new int[length];
    for (int i = 0; i < length; i++) {
        if (flag[0][i]) {//不用切割
            fp[i] = 0;
            continue;
        }
        fp[i]=fp[i-1]+1;//不满足上面的条件就进行一次切割
        //如果切割多次的范构成了回文，则表示之前切割的是一回文的一部分，将切割进行回溯，
        //窗口回溯法，从i-1开始往回找，每次区间形成一个更大的回文时切割数就会减小
        for (int j = i-1; j >0 ; j--) {
            if(flag[j][i])fp[i] = Math.min(fp[i], fp[j - 1] + 1);
        }
    }
    return fp[length - 1];
}
```