## [995. K 连续位的最小翻转次数](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/)

### 获取状态判断翻转

>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。
>
>返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。
>

一开始没有理解到题意，想不出解法，直到看了大神题解

解法逻辑

1. 由题意得知：遍历数组a，每当遇到**0**时进行翻转（**i到i+k**的状态都**++**）

2. 创建保存每个元素状况的窗口容器：

   1. 当元素**状态为奇数&&元素值为1**
   2. 当元素**状态为偶数&&元素值为0**

   满足上述条件进行翻转

3. 翻转到最后时，如果发生越界，则表示无法通过1的逻辑，**抛出-1**

```java
public static int minKBitFlips(int[] a, int k) {
        //尝试滑窗思想
        /*
        通过观察，我们可以隐约发现，每次应该在第一个0元素位置开始反转，如果能够使得整个数组不存在0，即返回res作为反转次数。
        1. 当反转次数为奇数次，元素会由0 -> 1，1 -> 0; 当反转次数为偶数次，元素不变;
        2. 由于我们关注元素的奇偶性质，所以我们可以在处理过的元素中+2，这样可以保持性质不变；
        3. 同时我们还需要关注同一元素在窗口内反转了几次，用windowFlip表示。这样的话如果元素为0，则满足 windowFlip % 2 == A[i]
        */
        int resNum = 0;
        int length = a.length;
        int[] win = new int[length];
        try{
            for (int i = 0; i < length; i++) {
                if(win[i]%2==0&&a[i]==0) {
                    resNum++;
                    for (int j = i; j < i+k; j++) {
                        win[j]++;
                    }
                }else if(win[i]%2==1&&a[i]==1){
                    resNum++;
                    for (int j = i; j < i+k; j++) {
                        win[j]++;
                    }
                }
            }
        } catch (Exception e){
            return -1;
        }
        return resNum;
    }	
```

