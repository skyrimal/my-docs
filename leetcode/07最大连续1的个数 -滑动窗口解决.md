## [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

> 本题本身不难，但是需要考虑多种情况比较麻烦

1. 当==右指针指向元素为0==时计数**resNum++**

2. 当计数到**k**，且==右指针无法移动==时，开始移动**左指针**

   > 右指针还指向**0**时无法移动

   1. 当左指针指向**0**时，移动左指针并**resNum——**
   2. 当左指针为**1**时，一直移动左指针到指针指向**0**移动过时停止并**resNum——**

3. 结束循环后要兜底处理最后右指针一直移动到最右的情况

4. 排除**k**为0的情况

   > 当k为0时，左指针可能一直指向一个**0**且右指针一直移动，结果会比需要值大1

   ```java
   public static int longestOnes(int[] a, int k) {
       //使用滑窗法
       //每当条件不满足时刷新滑窗
       int length = a.length;
       int max = 0;
       //初始化窗口
       int lp = 0;
       int resNum = 0;
       for (int rp = 0; rp < length; rp++) {
           if(resNum>=k){
               if(a[rp]==0){//能够移动的条件
                   max=Math.max(max,rp-lp);//取值
                   if(a[lp]==0){//左指针收缩条件
                       lp++;
                       resNum--;
                   }else{
                       for (int i = lp; i < rp; i++) {//左指针连续收缩条件
                           if(a[i]==1)lp++;
                           else{
                               lp++;
                               resNum--;
                               break;
                           }
                       }
                   }
               }
           }
           if(a[rp]==0)resNum++;//记录翻转
       }
       if(resNum<=k){
           max=Math.max(max,length-lp);
       }else{//处理为0等翻转次数大于k的情况
           max=Math.max(max,length-lp-1);
       }
       return max;
   }
   ```

