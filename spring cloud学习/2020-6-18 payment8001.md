# 创建一个逻辑应用层提供方微服务应用

## 建module

### 1.写pom

最基础的module子模块pom文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>cloud2020</artifactId>
        <groupId>com.atguigu.springcloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <artifactId>cloud-provider-payment8001</artifactId>

    <dependencies>

        <!-- spring-boot基础依赖 -->
        <!-- web依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- 图像处理图形化展示和坐标监控 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- 假的热部署，会监听classpath下的文件变动，并且会立即重启应用 -->
        <!--
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        -->

        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>



        <!--eureka 服务注册客户端-->
        <!--
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        -->

        <!--Zipkin是一个链路跟踪工具，可以用来监控微服务集群中调用链路的通畅情况-->
        <!--
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zipkin</artifactId>
        </dependency>
        -->
    </dependencies>


</project>
```



### 2.写yml

```yml
server:
  port: 8001

spring:
  application:
    name: cloud-payment-service
  datasource:
    #使用阿里巴巴的数据库连接池，功能更强大
    type: com.alibaba.druid.pool.DruidDataSource
    #mysql-connect工具中的连接驱动
    driver-class-name: com.mysql.cj.jdbc.Driver
    #创建连接三件套
    url: jdbc:mysql://192.168.50.113:13306/cloud_test?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true
    username: root
    password: toor

mybatis:
  #mapper.xml在的位置，classpath:指的是配置文件所在的目录，即resources
  mapper-locations: classpath:mapper/*.xml
  #实体类位置，有了之后mapper.xml中就可以直接写类名
  type-aliases-package: com.skyrimal.learn.springcloud.entity
```



### 3.主启动类

```java
@SpringBootApplication
public class PaymentMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8001.class,args);
    }
}
```



### 4.业务类





##Mybatis 数据库连接池url详解

```yml
    url: jdbc:mysql://127.0.0.1:3306/cloud_test?characterEncoding=UTF-8&useUnicode=true&useSSL=false&tinyInt1isBit=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true

```

### characterEncoding=UTF-8&useUnicode=true

 **指定字符的编码、解码格式**

###useSSL=false

```
异常信息

 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.

不建议在没有服务器身份验证的情况下建立SSL连接。根据MySQL 5.5.45+、5.6.26+和5.7.6+的要求，如果不设置显式选项，则必须建立默认的SSL连接。需要通过设置useSSL=false来显式禁用SSL，或者设置useSSL=true并为服务器证书验证提供信任存储。

解决方案
jdbc:mysql://localhost:3306/test?characterEncoding=utf8&useSSL=true
```



### tinyInt1isBit=false

```
数据库一个表中有一个tinyint类型的字段，值为0或者1，如果取出来的话，0会变成false，1会变成true。

MySQL保存boolean值时用1代表TRUE，0代表FALSE。boolean在MySQL里的类型为tinyint(1)。MySQL里有四个常量：true,false,TRUE,FALSE分别代表1,0,1,0。

场景:

　　字段：status (值为1,2,3)

　　类型：tinyint  长度：1(有符号的)

　　结果：查询出来的数据列表，状态值不管是1还是2还是3，都是"boolean true"

分析并解决：

　　分析：由于MySql中没有boolean类型，所以会用到tinyint[1]类型来表示,在mysql中boolean=tinyint[1]

　　解决：tinyint类型长度的问题，当我把长度改成4时，查询结果就正常了

猜想并使用新的方法解决：

　　如果不改变类型的长度，怎么让查询的结果正确呢？需要在查询语句上面做修改了

　　在你需要执行的sql语句中，把这个状态字段*1，结果就会得到数据库存的值了(注意：记得加别名，不然查询出来的就是status*1 => '1')
复制代码

SELECT
    id,
    name,
    status*1 AS status,
    add_time
FROM
    tableName
WHERE
    play_type = 0

复制代码

总结一下以上的两种解决方法：

　　1.修改tinyint类型的长度

　　2.在查询的sql语句上面做修改 

所以由这里可以看出，当你使用tinyint[1]来存储超过0,1两个值以外的值，比如存储2，那这个2就是脏数据就用tinyint[4]，tinyint[1]只适用于存储0和1两个值，也即真和假，true和false

　　一般的，咱们如果存的是纯数字的话，建议用tinyint，如果是字符串，且是固定长度的，建议用char,而enum的枚举字段，使用的使用需要慎重考虑，避免带来不必要的麻烦

还有一种方式是在连接url上添加 tinyInt1isBit=false ：
```

### serverTimezone=Asia/Shanghai

时区，要注意如果UTC代表是世界世界，跟中国世界差8个小时

### rewriteBatchedStatements=true

**批量执行==》JDBC连接URL字符串中需要新增一个参数：rewriteBatchedStatements=true**

```
MySQL的JDBC连接的url中要加rewriteBatchedStatements参数，并保证5.1.13以上版本的驱动，才能实现高性能的批量插入。
MySQL JDBC驱动在默认情况下会无视executeBatch()语句，把我们期望批量执行的一组sql语句拆散，一条一条地发给MySQL数据库，批量插入实际上是单条插入，直接造成较低的性能。
只有把rewriteBatchedStatements参数置为true, 驱动才会帮你批量执行SQL
另外这个选项对INSERT/UPDATE/DELETE都有效

添加rewriteBatchedStatements=true这个参数后的执行速度比较：
同个表插入一万条数据时间近似值：
JDBC BATCH 1.1秒左右 > Mybatis BATCH 2.2秒左右 > 拼接SQL 4.5秒左右

作者：晚歌y
链接：https://www.jianshu.com/p/0f4b7bc4d22c
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## myabtis插入数据后返回主键的操作流程

###1.标签上加上useGeneratedKeys="true" keyProperty="主键列名"

```xml
<insert id="create" parameterType="Payment" useGeneratedKeys="true" keyProperty="id">
```

### 2.将插入实体进行输出，查看插入后实体内容

```java
	    Payment _payment =payment;
        paymentDao.create(_payment);
        log.info("_payment插入后，_paymant的数据："+payment);
```

输出log

>2020-06-18 22:43:57.719  INFO 6948 --- [nio-8001-exec-7] c.s.l.s.service.impl.PaymentServiceImpl  : _payment插入后，_paymant的数据：Payment(id=35, serial=尝试插入后返回主键)