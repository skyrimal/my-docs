##1.网关不能有可视化插件

```xml
<!-- 不能用 -->
<!-- web依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- 图像处理图形化展示和坐标监控 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

##2.网关可以通过yml文件和@Bean进行设置

```yml
#主yml
spring:
  profiles:
    # 指定配置
    # route_simple：简单尝试
    # route_stripPrefix：截取请求
    # route_uri：转发指定地址并传入参数
    # route_addRequestParameter：转发指定服务并传入参数
    # route_hystrix：熔断
    # route_requestRateLimiter：限流
    # route_all：综合
    active: route_simple
    
    
#子模块yml    
spring: 
  # 配置文件名称，用来标识不同环境的配置。由 spring.profiles.active 的值来决定使用哪组配置。
  ## 简单尝试
  profiles: route_simple
  application:
    # 应用名称
    name: gateway-master
  cloud:
    gateway:
      discovery:
        locator:
          # 是否和服务注册与发现组件结合，设置为 true 后可以直接使用应用名称调用服务，启动后服务可以不用ip/域名，直接用lp://{服务名}
          enabled: true
      # 路由（routes：路由，它由唯一标识（ID）、目标服务地址（uri）、一组断言（predicates）和一组过滤器组成（filters）。filters 不是必需参数。）
      routes:
      # 路由标识（id：标识，具有唯一性）   简单尝试
      - id: route_simple
        # 目标服务地址（uri：地址，请求转发后的地址）
        uri: https://www.zouwencong.com
        # 路由条件（predicates：断言，匹配 HTTP 请求内容）
        predicates: #断言，可以对多个条件进行判断
        ## 转发地址格式为 uri/archive
        - Path=/archive
```

```java

@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator routes(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("path_baidu", //id唯一标识，可以随便写
                       r -> r.path("/guonei")//路由名
                        .uri("http://news.baidu.com/guonei"))//路由指向的地址
                .build();
    }
}

/**
* 测试发现 r.path中必须与地址最后url完全一样，否则会出错
* uri在地址后的部分都是多余的，访问的地址是 {uri中的地址}/path
* 总结出：：gateway的作用是隐藏网址和ip，但是不影响url部分
* 同时，只有被配置了的url才能被访问
* routes()后调用返回this，即可以多次调用route()方法
*/
```



##3. 断言判断限制范围

![在这里插入图片描述](../%E6%96%AD%E8%A8%80)

###资料位置

[==***断言资料***==](https://blog.csdn.net/forezp/article/details/84926662)

## 4. gateway过滤器

> 比如：：用来判断用户是否有权限访问

​    Spring Cloud  Gateway同zuul类似，有“pre”和“post”两种方式的filter。客户端的请求先经过“pre”类型的filter，然后将请求转发到具体的业务服务，比如上图中的user-service，收到业务服务的响应之后，再经过“post”类型的filter处理，最后返回响应到客户端。

   

##YML

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: http://httpbin.org:80/get
        filters:
        - AddRequestHeader=X-Request-Foo, Bar #请求头上加一个键值对
        
```

读取yml的源码

```java
public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory {

	@Override
	public GatewayFilter apply(NameValueConfig config) {
		return (exchange, chain) -> {
			ServerHttpRequest request = exchange.getRequest().mutate()
					.header(config.getName(), config.getValue())
					.build();

			return chain.filter(exchange.mutate().request(request).build());
		};
    }

}
```

## YML2

```yml
spring:
  cloud:
    gateway:
      routes:
      - id: rewritepath_route
        uri: https://blog.csdn.net
        predicates:
        - Path=/foo/**
        filters:
        - RewritePath=/foo/(?<segment>.*), /$\{segment} #替换 访问：/foo/{随便啥} 调用服务：/{随便啥}
```



##java方法 实现GlobalFilter,Ordered接口

```java
public class RequestTimeFilter implements GatewayFilter, Ordered {//不加@Component,也可以在配置java文件中插入过滤器

    private static final Log log = LogFactory.getLog(GatewayFilter.class);
    private static final String REQUEST_TIME_BEGIN = "requestTimeBegin";

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        exchange.getAttributes().put(REQUEST_TIME_BEGIN, System.currentTimeMillis());
        return chain.filter(exchange).then(
                Mono.fromRunnable(() -> {
                    Long startTime = exchange.getAttribute(REQUEST_TIME_BEGIN);
                    if (startTime != null) {
                        log.info(exchange.getRequest().getURI().getRawPath() + ": " + (System.currentTimeMillis() - startTime) + "ms");
                    }
                })
        );

    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```

```java
 @Bean
    public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) {
        // @formatter:off
        return builder.routes()
                .route(r -> r.path("/customer/**")
                        .filters(f -> f.filter(new RequestTimeFilter())//可以在这里才引入过滤器
                                .addResponseHeader("X-Response-Default-Foo", "Default-Bar"))
                        .uri("http://httpbin.org:80/get")
                        .order(0)
                        .id("customer_filter_router")
                )
                .build();
        // @formatter:on
    }
```





gateway过滤器结构

![微信截图_20181204175448.png](../%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84,png)

​    过滤器工厂的顶级接口是GatewayFilterFactory，我们可以直接继承它的两个抽象类来简化开发AbstractGatewayFilterFactory和AbstractNameValueGatewayFilterFactory，这两个抽象类的区别就是前者接收一个参数（像StripPrefix和我们创建的这种），后者接收两个参数（像AddResponseHeader）。

​    过滤器工厂的顶级接口是GatewayFilterFactory，有2个两个较接近具体实现的抽象类，分别为AbstractGatewayFilterFactory和AbstractNameValueGatewayFilterFactory，这2个类前者接收一个参数，比如它的实现类RedirectToGatewayFilterFactory；后者接收2个参数，比如它的实现类AddRequestHeaderGatewayFilterFactory类。现在需要将请求的日志打印出来，需要使用一个参数，这时可以参照RedirectToGatewayFilterFactory的写法。



```java
public class RequestTimeGatewayFilterFactory extends AbstractGatewayFilterFactory<RequestTimeGatewayFilterFactory.Config> {


    private static final Log log = LogFactory.getLog(GatewayFilter.class);
    private static final String REQUEST_TIME_BEGIN = "requestTimeBegin";
    private static final String KEY = "withParams";

    @Override
    public List<String> shortcutFieldOrder() {
        return Arrays.asList(KEY);
    }

    public RequestTimeGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            exchange.getAttributes().put(REQUEST_TIME_BEGIN, System.currentTimeMillis());
            return chain.filter(exchange).then(
                    Mono.fromRunnable(() -> {
                        Long startTime = exchange.getAttribute(REQUEST_TIME_BEGIN);
                        if (startTime != null) {
                            StringBuilder sb = new StringBuilder(exchange.getRequest().getURI().getRawPath())
                                    .append(": ")
                                    .append(System.currentTimeMillis() - startTime)
                                    .append("ms");
                            if (config.isWithParams()) {
                                sb.append(" params:").append(exchange.getRequest().getQueryParams());
                            }
                            log.info(sb.toString());
                        }
                    })
            );
        };
    }


    public static class Config {

        private boolean withParams;

        public boolean isWithParams() {
            return withParams;
        }

        public void setWithParams(boolean withParams) {
            this.withParams = withParams;
        }

    }
}
```

在上面的代码中 apply(Config  config)方法内创建了一个GatewayFilter的匿名类，具体的实现逻辑跟之前一样，只不过加了是否打印请求参数的逻辑，而这个逻辑的开关是config.isWithParams()。静态内部类类Config就是为了接收那个boolean类型的参数服务的，里边的变量名可以随意写，但是要重写List shortcutFieldOrder()这个方法。
 。

需要注意的是，在类的构造器中一定要调用下父类的构造器把Config类型传过去，否则会报ClassCastException

最后，需要在工程的启动文件Application类中，向Srping Ioc容器注册RequestTimeGatewayFilterFactory类的Bean。

```java
    @Bean
    public RequestTimeGatewayFilterFactory elapsedGatewayFilterFactory() {
        return new RequestTimeGatewayFilterFactory();
    }

```

然后可以在配置文件中配置如下：

```yml
spring:
  profiles:
    active: elapse_route

---
spring:
  cloud:
    gateway:
      routes:
      - id: elapse_route
        uri: http://httpbin.org:80/get
        filters:
        - RequestTime=false
        predicates:
        - After=2017-01-20T17:42:47.789-07:00[America/Denver]
  profiles: elapse_route

```

启动工程，在浏览器上访问localhost:8081?name=forezp，可以在控制台上看到，日志输出了请求消耗的时间和请求参数。