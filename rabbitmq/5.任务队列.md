# 任务队列

> 生产者生产数据进入一个队列，消费者也从一个队列中获取数据 这里不需要交换机的概念，当然，本处是有交换机的，其为默认的交换机 ""的direct 直连队列 
>
> 使用默认交换机时，需要添加默认路由，默认路由必须与队列重名才能指向队列

会话调用发送多个消息到最简单的队列

```java
channel.queueDeclare(RabbitMqManage.QUEUE_NAME, true, false, false, null);//声明队列
channel.basicPublish("", RabbitMqManage.QUEUE_NAME, null, (message+1).getBytes());
channel.basicPublish("", RabbitMqManage.QUEUE_NAME, null, (message+2).getBytes());
channel.basicPublish("", RabbitMqManage.QUEUE_NAME, null, (message+3).getBytes());
```

下方多个监听相同队列的消费者会轮询获取发送的消息

![消费者](E:%5Cmd%5C%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%5C%E5%AD%A6%E4%B9%A0%5C%E5%9B%BE%E7%89%87%5Cimage-20210101160032229.png)

## 补充，队列一次处理一条数据

```java
/*
请求此通道的特定预取计数“服务质量”设置。
注意：预取计数必须介于0和65535之间（在AMQP 0-9-1中为无符号短）。
参数：
prefetchCount—服务器将传递的最大邮件数，如果不受限制，则为0
**/
channel.basicQos(1);//消费者处设置，消费者服务器每次只能消费一个消息

//不会自动确认消息被消费
channel.basicConsume(RabbitMqManage.QUEUE_NAME, false, new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("慢速处理"+new String(body,"utf-8"));
        //1.消息id
        //2.是否开启多个消息同时确认
        channel.basicAck(envelope.getDeliveryTag(),false);//
    }
});
```

 