# 发布队列–广播 

> DIRECT
>
> 添加交换机概念,一个交换机对应多个队列，一个队列对应一个消费者。
>
> 生产者将消息发送到交换机中，交换机会将消息发送给每一个队列

## 1.在发送接收前

> 会话需要初始化交换机，并给交换机绑定队列

```java
// 声明交换机
// 1.交换机名
// 2.交换机类型
// 3.持久化
channel.exchangeDeclare(RabbitMqManage.EXCHANGE_PM, BuiltinExchangeType.DIRECT,true);//声明直连交换机

// 声明多个队列对应多个消费者
channel.queueDeclare(RabbitMqManage.QUEUE_PHONE, true, false, false, null);//声明队列
channel.queueDeclare(RabbitMqManage.QUEUE_EMAIL, true, false, false, null);//声明队列

//绑定交换机会绑定到交换机上
// 1.队列名
// 2.交换机名
// 3.路由key，工作模式中无意义
channel.queueBind(RabbitMqManage.QUEUE_PHONE,RabbitMqManage.EXCHANGE_PM,"");
channel.queueBind(RabbitMqManage.QUEUE_EMAIL,RabbitMqManage.EXCHANGE_PM,"");
```

2.发送消息到交换机上

```java
for (int i = 0; i < 5; i++) {
    channel.basicPublish(RabbitMqManage.EXCHANGE_PM,"",null,(message+i).getBytes());
    System.out.println("发送第"+i+"条消息::"+message);
}
```

## 3.接收消息

```java
channel.basicConsume(RabbitMqManage.QUEUE_EMAIL, true, manage.listenConsumer("Email"));
```

## 补充 广播时创建临时队列 交换机类型：fanout

不同在于，当出现新消费者时，才创建新的队列绑定到交换机中

```java
//获取临时队列
String queue = channel.queueDeclare().getQueue();
//临时队列绑定交换机
channel.queueBind(queue,"logs","");

channel.basicConsume(queue,new DefaultConsumer(channel){
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        System.out.println(new String(body,"utf-8"));
    }
});
```

### 直连与广播的区别

直连型交换机（direct exchange）是**根据消息携带的路由键（routing key）将消息投递给对应队列的**。**直连交换机用来处理消息的单播路由（unicast routing）**（尽管它也可以处理多播路由）。

扇型交换机（funout  exchange）将**消息路由给绑定到它身上的所有队列，而不理会绑定的路由键**。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝==**分别发送给这所有的N个队列**==。扇型用来交换机处理消息的==**广播路由**==（broadcast routing）。