# 流程

> ==**注意：：声明的概念是没有就生成，有就选中**==

## 1.创建对RabbitMq的连接

```java
ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.setHost("127.0.0.1");
connectionFactory.setPort(5672);//默认通信端口
connectionFactory.setUsername("learn-user");
connectionFactory.setPassword("toor");
connectionFactory.setVirtualHost("/learn-test");
Connection connection = connectionFactory.newConnection();
```

## 2.创建对RabbitMq的操作会话

```java，
Channel channel = connection.createChannel();
```

## 3.发起队列声明会话

> 本次是最简单的流程，所以创建的队列在默认的一个名为空字符串（“”）的交换机中

```java
// (1.队列名称，
// 2.是否持久化，
// 3.是否独占连接==‘只有本连接可以使用，
// 4.连接关闭后自动删除队列’，是否自动删除，
// 5.扩展参数)
channel.queueDeclare(QUEUE_NAME, true, false, false, null);//声明队列
```

## 4.发起发送消息会话

> 所有涉及到默认交换机和路由的参数，都为空字符串，不能为null，不然会报错找不到

```java
//1.exchange 交换机，rabbitmq存在一个默认的直连交换机，交换机有名，名为 空 ""
//2.routingKey 路由key，交换机根据根据路由key来将消息转发到指定的队列，
// 如果使用默认交换机，routingKey设置为队列的名称
//3.props，消息的属性
//4.body，消息内容
String message = "hello world Skyrimal";
channel.basicPublish("", QUEUE_NAME, null, (message+1).getBytes());
```

## 5.监听队列消息并回调改变方法

```java
// 监听队列
// 1.指定队列
// 2.是否自动回复，false时需要通过编程进行回复
// 3.消费方法，接收到消息需要执行的回调方法

// 接收到消息的回调方法
DefaultConsumer defaultConsumer = new DefaultConsumer(channel) {
    /**
     *
     * @param consumerTag 消费者标签 可以在监听队列时设置
     * @param envelope 信封 可以获取交换机、消息id
     * @param properties 消息属性 可以获取发送消息时的属性
     * @param body 获取消息的内容
     * @throws IOException
     */
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        long deliveryTag = envelope.getDeliveryTag();//lang类型的消息id 可用于确认消息已接收
        String exchange = envelope.getExchange();//交换机名
        String routingKey = envelope.getRoutingKey();//路由键
        System.out.println(new String(body, "utf-8"));
    }
};
channel.basicConsume(QUEUE_NAME, true, defaultConsumer);
```

