# 对应任务队列来说



> 逻辑只管队列下多个应用分工的，需要堵塞消息传输等待处理的情况
>
> 会使用到执行basicPublish时的 props 属性

But what if we need to run a function on a remote computer and wait for the result? Well, that's a different story. This pattern is commonly known as *Remote Procedure Call* or *RPC*.

但是如果我们需要在远程计算机上运行一个方法（函数）并等待结果呢？好吧，那是另一回事。这种模式通常称为远程过程调用或RPC。

### Callback queue

To illustrate how an RPC service could be used we're going to create a simple client class. It's going to expose a method named call which sends an RPC request and blocks until the answer is received

为了说明如何使用RPC服务，我们将创建一个简单的客户机类。它将公开一个名为call的方法，该方法发送一个RPC请求并阻塞，直到收到应答：

```java
FibonacciRpcClient fibonacciRpc = new FibonacciRpcClient();
String result = fibonacciRpc.call("4");
System.out.println( "fib(4) is " + result);
```

```
	Although RPC is a pretty common pattern in computing, it's often criticised. The problems arise when a programmer is not aware whether a function call is local or if it's a slow RPC. Confusions like that result in an unpredictable system and adds unnecessary complexity to debugging. Instead of simplifying software, misused RPC can result in unmaintainable spaghetti code.

Bearing that in mind, consider the following advice:

- Make sure it's obvious which function call is local and which is remote.
- Document your system. Make the dependencies between components clear.
- Handle error cases. How should the client react when the RPC server is down for a long time?

When in doubt avoid RPC. If you can, you should use an asynchronous pipeline - instead of RPC-like blocking, results are asynchronously pushed to a next computation stage.

	虽然RPC是计算中非常常见的模式，但它经常受到批评。当程序员不知道某个函数调用是本地调用还是慢速RPC时，就会出现问题。
	这样的混乱会导致不可预知的系统，并给调试增加不必要的复杂性。与简化软件相反，误用RPC会导致无法维护的意大利面代码。
考虑到这一点，请考虑以下建议：
-确定哪个函数调用是本地的，哪个是远程的。
-记录您的系统。明确组件之间的依赖关系。
-处理错误案例。当RPC服务器长时间停机时，客户端应该如何反应？
如有疑问，请避免使用RPC。如果可以的话，应该使用异步管道，而不是类似RPC的阻塞，结果将异步推送到下一个计算阶段。

```

> 面条式*代码*（spaghetti code）是非结构化和难以维护的*源代码*的贬义词组，广泛地解释。 意大利面条代码可能由多种因素引起，例如易变的项目要求，缺乏编程风格规则以及能力或经验不足。

### Callback queue

In general doing RPC over RabbitMQ is easy. A client sends a request message and a server replies with a response message. In order to receive a response we need to send a 'callback' queue address with the request. We can use the default queue (which is exclusive in the Java client). Let's try it:

一般来说，在RabbitMQ上执行RPC很容易。客户端发送一条请求消息，服务器用一条响应消息进行回复。为了接收响应，我们需要随请求一起发送“回调”队列地址。我们可以使用默认队列（在Java客户机中是独占的）。让我们试试

```java
callbackQueueName = channel.queueDeclare().getQueue();

BasicProperties props = new BasicProperties
                            .Builder()
                            .replyTo(callbackQueueName)
                            .build();

channel.basicPublish("", "rpc_queue", props, message.getBytes());


//We need this new import:
//import com.rabbitmq.client.AMQP.BasicProperties;
// ... then code to read a response message from the callback_queue ...
```

```

    Message properties

    The AMQP 0-9-1 protocol predefines a set of 14 properties that go with a message. Most of the properties are rarely used, with the exception of the following:

        deliveryMode: Marks a message as persistent (with a value of 2) or transient (any other value). You may remember this property from the second tutorial.
        contentType: Used to describe the mime-type of the encoding. For example for the often used JSON encoding it is a good practice to set this property to: application/json.
        replyTo: Commonly used to name a callback queue.
        correlationId: Useful to correlate RPC responses with requests.

消息属性
amqp0-9-1协议预定义了一组14个与消息相关的属性。除以下情况外，大多数属性很少使用：
deliveryMode：将消息标记为持久（值为2）或暂时（任何其他值）。您可能还记得第二个教程中的这个属性。
contentType：用于描述编码的mime类型。例如，对于经常使用的JSON编码，将此属性设置为：application/JSON是一种很好的做法。
replyTo：通常用于命名回调队列。
correlationId：用于将RPC响应与请求关联起来。

```

## 扩展

### 一个完整地RPC需要经历那些过程？

- **1.序列化**：RPC是一个远程调用，所以必须要通过网络来传输数据。调用方的请求出入参数都是对象，就需要序列化对象为可传输的二进制。
- **2.传输数据**：调用方将二进制数据传输给服务提供方，RPC 一般默认采用 TCP 来传输，因为其可靠性。
- **3.反序列化**：根据特定的协议，服务提供方可以从二进制数据中正确的分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象。
- **4.方法调用**：根据反序列化得到的请求对象，找到对应的类，完成方法调用。
- **5.返回请求**：将执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。
- 在这些的基础上，可以对其进行简化，不必关注其中复杂的操作，如调用方的序列化，网络传输调用，反序列化。可以像Spring的 AOP 一样，采用动态代理的技术，通过字节码增强对方法进行拦截增强，以便于增加需要的额外处理逻辑，上述操作都可以通过动态代理来解决。
- 由服务提供者给出业务接口声明，在调用方的程序里面，RPC  框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。